#define _CRT_SECURE_NO_WARNING 1
#include<stdio.h>
//
////判断大端存储和小端存储
//int main()
//{
//	int a = 1;
//	char* p = (char*)&a;//强制转换，把a的地址强行转换为char*
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}


//
////输出什么?
//// -1 -1 255
//int main()
//{
//	char a = -1;
//	//11111111(储存的是补码)
//	signed char b = -1;
//	//11111111
//	unsigned char c = -1;
//	//11111111
//	printf("a=%d,b=%d,c=%d",a, b ,c);
//	//打印的时候进行整形提升，提升按照符号位整形提升，符号位是啥补啥。
//	return 0;
//}


//
////输出什么？
//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000
//	//11111111111111111111111101111111-反码
//	//11111111111111111111111110000000-补码
//	//存储整型提升的时候，按照关键字有无符号进行提升。
//	//存储了10000000
//	//11111111111111111111111110000000-补码
//	//11111111111111111111111110000000-打印时无符号位，因此认为原反补一样。
//	printf("%u\n",a);
//	//%u,打印10进制无符号数
//	return 0;
//}


////二进制存储的有符号char，负数为-128到-1，分别对应10000000(特殊规定了这个数是-128)和11111111
////正数为127-0，为01111111和00000000，127+1就会变为-128
////无符号的char为0-255，无论有无符号，都是闭合循环，也就是255+1变成0，-1+1=0，127+1=-128.



int main()
{
//计算规则:
//直接转化为二进制为源码，按位取反为反码，加一为补码。补码的补码是源码。
//计算的时候补码相加计算
int i = -20;
unsigned int j = 10;
printf("%d\n", i+j);

return 0;
}


//如果是数组类型，int = 0; 在数组中可以体现为\0


//浮点数
int main()
{
	int n = 9;
	float *pfloat = (float *)&n;
	printf("%d  ",0);
}