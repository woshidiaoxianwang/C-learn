#define _CRT_SECURE_NO_WARNING 1
#include<stdio.h>

//数组名只有单独放在sizeof里面和&的时候是整个数组的地址。否则是首元素地址
//&数组，取出的是整个数组的地址，也是4/8个字节大小
//strlen要考虑\0，但sizeof不管。
//字符串后面默认有\0，但数组后面没有
//strlen后面接收的参数是const char* str，接收的要是一个地址。
//数组再访问时候用下标和指针解引用同效果。
//&arr取出的是数组的地址，应该存在数组指针里

//char *p = "abcdef";//abcdef是一个常量字符串，这句代码的意思是p作为指针变量指向首元素a的地址。
//arr[0] == *(arr+0)  p[0] == *(p+0)


////二维数组
//int a[3][4] = {0}//先行后列
//a[0]相当于第一行作为一维数组的数组名，sizeof(arr[0])把数组名单独放在sizeof内，计算的是第一行的大小
//但是sizeof(arr[0]+1)，arr[0]就不单独在sizeof里面了，指向的就是第一行第一个元素的大小了。
//二维数组里，a[0],就是第一行的数组名。
//a+1就是第二行的地址
//&a[0]+1，意为第二行地址。&取出的a[0]就是第一行整行。
//sizeof(a[3]);sizeof内部不会实际计算。虽然没有第四行，但仍然能算出是和前几行一样。

//	int a[5] = {1,2,3,4,5};
//int *ptr = (int *)(&a + 1);//强制类型转换，但值没有变。
//
//
//1.
//struct test
//{
//	int Num;
//}* p;
//
////假设p 的值为0x10000,如下表达式的值分别为多少
////已知，结构体Test类型的变量大小是20个字节
//
//int main()
//{//因为是%p打印所以在0x后面要补全00。
//	printf("%p\n",p + 0x1);//p的大小是20，那么+0x1，就跳过20个字节，转化为16进制就是0x00100014
//	printf("%p\n",(unsigned long)p + 0x1);//转换为整数，加一为0x00100001
//	printf("%p\n",(unsigned int*)p + 0x1);//0x00100004
//	return 0;
//}
//
//




//2.
//int main()
//{
//	int a[4] = {1,2,3,4};
//	int *ptr1 = (int *)(&a + 1);
//	int *ptr2 = (int *)((int)a + 1);
//	printf("%x,%x",ptr1[-1], *ptr2);//ptr[-1]，意思就是*(ptr1+(-1))
//	return 0;
//}
//
//
//



//
////3.
//int main()
//{
//	int a[3][2] = { (0,1), (2,3), (4,5)};//逗号表达式，别被坑()不是{}
//	//这个二维数组是
//	//1  3
//	//5  0
//	//0  0
//	int *p;
//	p = a[0];
//	printf("%d", p[0]);
//	return 0;
//}

//
////p[4][2]
////等价于*(*(p+4)+2)
////%d,直接打印，%p打地址。


//
////4.
//int main()
//{
//	char *a[] = {"work","at","alibaba"};
//	//将常量字符串首字母的地址以指针形式存储，其他字母的地址不储存在此数组中。
//	//因此a是指针数组.
//	char**pa = a;//数组名是首元素地址。首元素又是个地址,因此是二级指针。
//
//	pa++;//pa++,以pa的形式向后跳过一个单位，也就是跳过了一个char*，但这个跳过依旧在数组里面跳过。
//	//就像int* +1以后跳过一个int一样，因此跳到了at的a的地址。
//	printf("%s\n",*pa);
//	return 0;
//}





//5. 指针面试题详解(4)片段2_0s
int main()
{
	char *c[] = {"ENTER","NEW","POINT","FITST"};
	char**cp[] = {c + 3, c + 2,c + 1,c};
	char***cpp = cp;

	printf("%s\n",**++cpp);//此处的++会永久改变cpp的值、
	printf("%s\n",*--*++cpp +3);//
	printf("%s\n",*cpp[-2] + 3);
	printf("%s\n",cpp[-1][-1] +1);
	return 0;
}